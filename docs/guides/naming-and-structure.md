---
bodyclass: docs
title: Naming Conventions and Project Structure
headline: Naming Conventions and Project Structure
layout: docs
sidenav: doc-side-guides-nav.html
type: markdown
---

<p class="lead">Although some of features of the framework are configurable, 
in general we favors conventions over configuration. This document covers
the naming conventions used in the framework and how these conventions are used by 
the code generation. Also this guide describes standard structure of a Spine-based project.  

This guide assumes that you've read the [Introduction]({{site.baseurl}}/docs/guides/introduction.html) and
understand the basic [DDD, ES, and CQRS concepts]({{site.baseurl}}/docs/guides/concepts.html).

<div id="toc" class="toc mobile-toc"></div>

## Project directory structure

Projects based on the Spine framework are Gradle-based and follow the standard structure of 
the Gradle project. 

### Handcrafted source code

Following standard Gradle conventions a manually written code is created under the 
`src/main/` directory with subdirectories `proto`, `java`, etc. for corresponding languages. 

### Generated source code

Code generated by Protobuf Compiler and Spine Model Compiler is placed under the `generated` 
directory under the module directory.

### Example

Here's how a typical project structure would look like:

```
myproject
  module-1
    generated
       main
         java
         resources
         ...
       test
         java
         resources
         ...   
    src
       main
         java
         proto
       test
         java
         proto
    ...     
    build.gradle
  module-2
    generated
      ...
    src
      ...
    build.gradle
  ...
  build.gradle           
```

## Naming of proto files

Proto files are named using the `snake_case`, as defined by Protobuf. There are several special
kinds of files.

### `identifiers.proto`   

Commands and events reference business entities via their identifiers. 
Having typed identifiers makes a model type safe.
Although, the framework also supports `String`, `Integer`, and `Long` as valid ID types 
(and correspondingly `string`, `int32`, and `int64` in Protobuf), 
we strongly recommend defining custom ID types like `CustomerId`, `OrderId`, `ShipmentId`, etc. 
You can find similar cases in the framework code which has `EventId`, `CommandId`, `UserId`, 
`TenantId`, etc. 

Although, it is not a requirement, we found it convenient to define types of IDs in one file called
`identifiers.proto`. A typical project is likely to have more than one Bounded Context, so you
are going to have several `identifiers.proto` each residing under the directory with proto
files defining the data model of the corresponding Bounded Context.   

### Command definitions

Commands are defined in a file which names end with `commands.proto`. 
It can be simply `commands.proto`, but usually there are many commands that are handled by 
different aggregates. So, it's convenient to name such files after the type of the target
aggregate: `blog_commands.proto`, `order_commands.proto`, `customer_commands.proto`, etc.

### Event definitions

Similarly to commands, events are defined in files which names has the `events.proto` suffix:
`blog_events.proto`, `order_events.proto`, `customer_events.proto`.

### Rejection definitions

`Rejection` is a special — so to say “negative” — kind of events supported by the framework. 
Rejections are thrown if a command cannot be handled. Think exceptions, but of non-technical flavor.

Similarly to events, rejections are defined in files ending with `rejections.proto`: 
`blog_rejections.proto`, `order_rejections.proto`, `customer_rejections.proto`.

For each aggregate you are likely to have all the three kinds of files because a command leads to
an event, and it's likely there are conditions under which a command cannot be performed.

### Entity states

We recommend gathering definition of related entity states in a file named after a business model
thing. Suppose we have a `Task` aggregate, `TaskItem` and `TaskDetails` projections, and
a Process Manager which is responsible for movement of a task from one project to another, there
would be `task.proto` file, with all Task-related data types definitions. A project-related data
types would be defined in a `project.proto` file. 

As we wrote earlier, `TaskId` and `ProjectId` are defined in the `identifiers.proto` file, and
`task.proto` and `project.proto` import this file.

## Naming proto packages

//TODO:2018-11-21:alexander.yevsyukov: Write text.

## Naming Java packages

//TODO:2018-11-21:alexander.yevsyukov: Write text.

## Separating model, client, and server code

//TODO:2018-11-21:alexander.yevsyukov: Write text.      
